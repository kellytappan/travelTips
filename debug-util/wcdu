#!/usr/bin/env python

"""
Wolf Creek Debug Utility
"""

import sys
import argparse
import re
import subprocess
try:    from cStringIO import StringIO
except: from  StringIO import StringIO

from Menu          import Menu
from SesPageSas    import SesPageSas
from SesPageFile   import SesPageFile
from SesPageCli    import SesPageCli
from CliCmdSerial  import CliCmdSerial
from CliCmdSas     import CliCmdSas
from CliCmd        import CliCmd
from SesPage       import SesPage
from configuration import Configuration
from discovery     import Discovery

from ScsiPT import ScsiPT
from Cmd    import Cmd
from CDB    import CDB

# Set up communication paths.
#sp = SesPageSas("/dev/sg4")
#sp = SesPageFile()
#sp = SesPageCli(CliCmdSerial("/dev/ttyUSB0"))

cli = None
#cli = CliCmdSas("/dev/sg7", 1)
#cli = CliCmdSerial("/dev/ttyUSB0")

#Discovery.probe()
#sp       = Discovery.create_best(Discovery.CAP_SES)
#sp_short = Discovery.create_best(Discovery.CAP_SES_SHORT)
#cli      = Discovery.create_best(Discovery.CAP_CLI)

# utility functions

def indentedtext(head, text, tail):
    """
    Return head + text + tail, but with newlines in text replaced by as many
    spaces as there are in head.  This has the effect of lining up multiple
    lines in text.
    """
    return head + text.replace("\n", "\n"+" "*len(head)) + tail

def dump_fields(fl):
    if fl:
        for f in fl:
            print f.val, f.name

def dumpbuf(buf):
    """
    Print a buffer as hexadecimal bytes.
    This code is not pretty.
    """
    a = 0
    for i in buf:
        if isinstance(i,str):
            i=ord(i)
        if a % 16 == 0:
            adr = "%.4x" % a
            hxd = ''
            asc = ''
        hxd += " %.2x" % (i)
        asc += i if (32 <= (i) and (i) < 128) else '.'
        if (a+1) % 16 == 0:
            print adr, "%-49s" % hxd, asc
        a += 1
    if a % 16 != 0:
        print adr, "%-49s" % hxd, asc

def pbo(f, printit=True):
    """
    Print Byte Offset, if so configured.
    """
    if Configuration.getByteoffsets():
        bostr = '(' + "%.4X"%f.byteoffset + ') '
    else:
        bostr = ""
    if printit:
        sys.stdout.write(bostr)
    return bostr
def pbob(printit=True):
    """
    Print Byte Offset, but Blanks instead.
    Print as many spaces as characters from pbo.
    """
    if Configuration.getByteoffsets():
        bostr = "       "
    else:
        bostr = ""
    if printit:
        sys.stdout.write(bostr)
    return bostr

def auto_configure():
    global sp, sp_short, cli
    global verbose
    Discovery.close_all()
    Discovery.probe()
    sp       = Discovery.create_best(Discovery.CAP_SES        )
    sp_short = Discovery.create_best(Discovery.CAP_SES_SHORT  )
    cli      = Discovery.create_best(Discovery.CAP_FAN_CONTROL) or \
               Discovery.create_best(Discovery.CAP_CLI        )
    if verbose:
        print "sp       =", Discovery.find_best(Discovery.CAP_SES      )
        print "sp_short =", Discovery.find_best(Discovery.CAP_SES_SHORT)
        print "cli      =", Discovery.find_best(Discovery.CAP_CLI      )

def SesPage_create(device):
    if "sg"        in device: return SesPageSas (device)
    if "tty"       in device: return SesPageCli (CliCmdSerial(device))
    if "/dev/" not in device: return SesPageFile(device)
    return None

def CliCmd_create(device):
    if "sg"  in device: return CliCmdSas   (device.split(','))
    if "tty" in device: return CliCmdSerial(device)
    return None

def get_input(prompt, p):
    """
    Print optional prompt, then get input.
    <ctrl>-C aborts the program.
    <ctrl>-D raises EOFError.
    """
    if p:
        return p.pop(0)
    else:
        sys.stdout.write(prompt)
        try:
            rawinp = raw_input()
        except KeyboardInterrupt:
            print
            sys.exit()
        except EOFError:
            print
            raise EOFError
        return rawinp

def print_status(pagenum, extras_func=None, param=None):
    if not sp: return
    page02 = sp.parse(sp.readpage(0x02))
    if not page02["data"]:
        page01 = sp.parse(sp.readpage(0x01))
        page02 = sp.parse(sp.readpage(0x02))

    for enclosure in page02["data"].enclosures.val:
        for typ in enclosure:
            if typ["type"] == pagenum:
                extras = extras_func(typ["type"], None, None, param) if extras_func else ""
                print "ele PDS   status", sespage02_specific(typ["type"]), extras
                elnum = -1
                for element in typ["elements"]:
                    prdfail  = "P" if element.prdfail .val else "."
                    disabled = "D" if element.disabled.val else "."
                    swap     = "S" if element.swap    .val else "."
                    elstat = element.elstat.val
                    status = element.status.val
                    specific = sespage02_specific(typ["type"], elnum, element)
                    extras = extras_func(typ["type"], elnum, element, param) if extras_func else ""
                    elnumstr = "%.3d" % elnum if elnum >= 0 else "all"
                    print elnumstr, prdfail+disabled+swap, elstat, "%.6X" % status, specific, extras
                    elnum += 1


# SES page display functions

def sespageall(p):
    """
    Print all implemented pages, indented with a page header.
    """
    Menu.clear()
    if not sp_short: return
    page00 = sp_short.parse(sp_short.readpage(0x00))
    for page in page00["data"]:
        for menu_item in ses_menu.data:
            try:
                match = int(menu_item[2], 0) == page[0]
            except:
                match = False
            if match:
                # Redirect stdout.
                save_stdout = sys.stdout
                sys.stdout = myIO = StringIO()
                menu_item[1](p)
                sys.stdout = save_stdout
                print "SES Page 0x%.2X: %s" % page
                myIO.seek(0)
                for line in myIO:
                    print "    " + line,
    Menu.wait()

def sespage00(p):
    Menu.clear()
    if not sp_short: return
    page00 = sp_short.parse(sp_short.readpage(0x00))
    print page00["pagedesc"] + ":"
    for p in page00["data"]:
        print "    %.2X: %s" % p
    Menu.wait()

def sespage01(p):
    Menu.clear()
    if not sp_short: return
    page01 = sp_short.parse(sp_short.readpage(0x01))
    for enclist in page01["data"].enclosures.val:
        pbo(enclist.subid   ); print "Enclosure #" + str(enclist.subid.val)
        pbo(enclist.logid   ); print "    %-31s:" % enclist.logid   .desc, "%X" % enclist.logid   .val
        pbo(enclist.vendor  ); print "    %-31s:" % enclist.vendor  .desc, enclist.vendor  .val
        pbo(enclist.product ); print "    %-31s:" % enclist.product .desc, enclist.product .val
        pbo(enclist.revision); print "    %-31s:" % enclist.revision.desc, enclist.revision.val
        pbob(); print "    Type Descriptors:"
        pbob(); print "        type possible text"
        for tdlist in enclist.typedesc.val:
            pbo(tdlist.type)
            print "        %.2X   %3d      %-s" % \
                (tdlist.type.val, tdlist.possible.val, pbo(tdlist.text, False) + tdlist.text.val)
    Menu.wait()

def sespage02_specific(typ, elnum=None, element=None):
    if   typ == 0x01:
        if elnum == None:
            return "ID slot fault off"
        elif elnum < 0:
            return ""
        else:
            return "%2s %3d  %3s   %2s " % \
                (
                 "X" if element.ident.val        else "",
                 element.slot_address.val,
                 "X" if element.fault_reqstd.val else "",
                 "X" if element.device_off.val   else "",
                 )
    elif typ == 0x02:
        if elnum == None:
            return "ID D+V D-V D+C swp fai on  off t+  tw  ac- dc-"
        elif elnum < 0:
            return ""
        else:
            return "%2s %2s  %2s  %2s  %2s  %2s  %2s  %2s  %2s  %2s  %2s  %2s" % \
                (
                 "X" if element.ident           .val else "",
                 "X" if element.dc_over_voltage .val else "",
                 "X" if element.dc_under_voltage.val else "",
                 "X" if element.dc_over_current .val else "",
                 "X" if element.hot_swap        .val else "",
                 "X" if element.fail            .val else "",
                 "X" if element.rqsted_on       .val else "",
                 "X" if element.off             .val else "",
                 "X" if element.overtmp_fail    .val else "",
                 "X" if element.temp_warn       .val else "",
                 "X" if element.ac_fail         .val else "",
                 "X" if element.dc_fail         .val else "",
                 )
    elif typ == 0x03:
        if elnum == None:
            return "ID fanspeed code off fail"
        elif elnum < 0:
            return ""
        else:
            return "%2s %7s  %3d  %2s  %2s" % \
                (
                 "X" if element.ident.val else "" ,
                 format(element.fan_speed.val*10, ",d"),
                 element.speed_code.val,
                 "X" if element.off.val   else "" ,
                 "X" if element.fail.val  else "" ,
                 )
    else:
        return ""

def sespage02(p):
    Menu.clear()
    if not sp: return
    page02 = sp.parse(sp.readpage(0x02))
    if not page02["data"]:
        page01 = sp.parse(sp.readpage(0x01))
        page02 = sp.parse(sp.readpage(0x02))

    for enclosure in page02["data"].enclosures.val:
        for typ in enclosure:
            pbob(); print "type:", "%.2X" % typ["type"], typ["text"]
            pbob(); print "    ele PDS   status", sespage02_specific(typ["type"])
            elnum = -1
            for element in typ["elements"]:
                prdfail  = "P" if element.prdfail .val else "."
                disabled = "D" if element.disabled.val else "."
                swap     = "S" if element.swap    .val else "."
                elstat = element.elstat.val
                status = element.status.val
                specific = sespage02_specific(typ["type"], elnum, element)
                elnumstr = "%.3d" % elnum if elnum >= 0 else "all"
                pbo(element.prdfail); print "    " + elnumstr, prdfail+disabled+swap, elstat, "%.6X" % status, specific
                elnum += 1
    Menu.wait()

def sespage05(p):
    Menu.clear()
    if not sp: return
    page05 = sp.parse(sp.readpage(0x05))
    if not page05["data"]:
        page01 = sp.parse(sp.readpage(0x01))
        page05 = sp.parse(sp.readpage(0x05))

    for enclosure in page05["data"].enclosures.val:
        for typ in enclosure:
            pbob(); print "type:", "%.2X" % typ["type"], typ["text"]
            elnum = -1
            for element in typ["elements"]:
                elnumstr = "%.3d" % elnum if elnum >= 0 else "all"
                pbo(element.hicrit)
                print "    " + elnumstr, "%3d %3d %3d %3d" % \
                (
                 element.hicrit.val,
                 element.hiwarn.val,
                 element.lowarn.val,
                 element.locrit.val,
                 )
                elnum += 1
    Menu.wait()

def sespage07(p):
    Menu.clear()
    if not sp: return
    page07 = sp.parse(sp.readpage(0x07))
    if not page07["data"]:
        page01 = sp.parse(sp.readpage(0x01))
        page07 = sp.parse(sp.readpage(0x07))

    for enclosure in page07["data"].enclosures.val:
        for typ in enclosure:
            pbob(); print "type:", "%.2X" % typ["type"], typ["text"]
            elnum = -1
            for element in typ["elements"]:
                #print "%.3d" % elnum, '"' + element.text.val + '"'
                elnumstr = "%.3d" % elnum if elnum >= 0 else "all"
                print indentedtext(pbo(element.text,False) + '    %.3s "' % elnumstr, element.text.val, '"')
                elnum += 1
    Menu.wait()

def sespage0a(p):
    Menu.clear()
    if not sp: return
    page0a = sp.parse(sp.readpage(0x0a))
    if not page0a["data"]:
        page01 = sp.parse(sp.readpage(0x01))
        page0a = sp.parse(sp.readpage(0x0a))

    addelpage = page0a["data"]
    headline = ''
    headline += "enc:typ:ele valid?  all?   init targ attached sas adr sas address      phy"
    pbob(); print headline
    for addel in addelpage.descriptors.val:
        leftline = ''
        if addel.eip.val:
            leftline += "%3d: %.2X:%3d " % addel.index.val
        else:
            leftline += "    "
        leftline += "invalid" if addel.invalid.val else "  valid"
        leftline += " "
        leftline += "notall" if addel.notall.val else "   all"
        for phy in addel.phydescriptors.val:
            si = 'S' if phy.ssp_init.val else '.'
            ti = 'T' if phy.stp_init.val else '.'
            mi = 'M' if phy.smp_init.val else '.'
            st = 'S' if phy.ssp_targ.val else '.'
            tt = 'T' if phy.stp_targ.val else '.'
            mt = 'M' if phy.smp_targ.val else '.'
            ports = si+ti+mi+'  '+st+tt+mt
            pbo(addel.invalid)
            print leftline, "%s  %.16X %.16X %.2X " % \
                (ports, phy.attached_sas_addr.val, phy.sas_addr.val, phy.phy_id.val)
            leftline = ' ' * len(leftline)
    Menu.wait()

def sespage0e(p):
    Menu.clear()
    if not sp: return
    page0e = sp.parse(sp.readpage(0x0e))
    for descriptor in page0e["data"].descriptors.val:
        pbo(descriptor.subid            ); print "Enclosure #" + str(descriptor.subid.val)
        pbo(descriptor.status           ); print "    status                : %.2X - %s" % (descriptor.status.val, descriptor.status_text.val)
        pbo(descriptor.additional_status); print "    additional status     : %.2X" % descriptor.additional_status.val
        pbo(descriptor.maxsize          ); print "    maximum size          : %s" % format(descriptor.maxsize.val, ",d")
        pbo(descriptor.expected_id      ); print "    expected buffer id    : %.2X" % descriptor.expected_id.val
        pbo(descriptor.expected_offset  ); print "    expected buffer offset: %.8X" % descriptor.expected_offset.val
    Menu.wait()

def sespage80(p):
    Menu.clear()
    if not sp: return
    page80 = sp.parse(sp.readpage(0x80))
    pbo(page80["data"].stop)
    if page80["data"].notavail.val:
        print "Not Available:", page80["data"].notavail.val
    else:
        print "Stop:", page80["data"].stop.val
        print indentedtext(pbo(page80["data"].log.val,False) + "Log: " + '"', page80["data"].log.val, '"')
    Menu.wait()

def sespageex(p, expandernum):
    Menu.clear()
    if not sp: return
    pageex = sp.parse(sp.readpage(0xe0 + expandernum))
    print "Expander #" + str(expandernum)
    for phydesc in pageex["data"].descriptors.val:
        for field in phydesc:
            pbo(field); print field.desc + ':', field.val
        print
    Menu.wait()

def sespagee0(p): sespageex(p, 0)
def sespagee1(p): sespageex(p, 1)
def sespagee2(p): sespageex(p, 2)
def sespagee3(p): sespageex(p, 3)
def sespagee4(p): sespageex(p, 4)
def sespagee5(p): sespageex(p, 5)

def sespagee8(p):
    Menu.clear()
    if not sp: return
    pagee8 = sp.parse(sp.readpage(0xe8))
    pbo(pagee8["data"].expanderid); print "Expander ID:", pagee8["data"].expanderid.val
    print indentedtext(pbo(pagee8["data"].response.val,False) + "Response: " + '"', pagee8["data"].response.val, '"')
    Menu.wait()

def sespages(p):
    if Configuration.interactive:
        # We're running interactive menus; continue on this way.
        ses_menu.run(p)
    else:
        # We were passed subcommands on the command line.  Search the menu for a matching page.
        inp = ses_menu.match(p[0])
        if isinstance(inp,int):
            # We got a unique match with menu item.  Run it.
            return ses_menu.data[inp][1](p[1:])
        for menu_item in ses_menu.data:
            # Find the given page.
            try:
                if int(menu_item[2], 0) == int(p[0], 0):
                    # Found a matching page; call its function.
                    return menu_item[1](p)
            except:
                pass
        else:
            # Couldn't find the specified page in the menu.
            if len(p) > 0:
                print "unimplemented page: " + p[0]
            else:
                print "need another parameter: the page number"


# configuration functions
def toggle_interactive(p): Configuration.setInteractive(not Configuration.getInteractive()); setup_config_menu()
def toggle_clear      (p): Configuration.setClear      (not Configuration.getClear      ()); setup_config_menu()
def toggle_byteoffsets(p): Configuration.setByteoffsets(not Configuration.getByteoffsets()); setup_config_menu()
def toggle_shortcuts  (p): Configuration.setShortcuts  (not Configuration.getShortcuts  ()); setup_config_menu()


# menu definitions and stubs

def discover_interfaces(p):
    Menu.clear()
    sas = Discovery.discover_sas()
    ser = Discovery.discover_serial()

    print "SAS devices"
    if len(sas) > 0:
        for dev in sas:
            print "    "+dev
    else:
        print "    None"

    print "Serial devices"
    if len(ser) > 0:
        for dev in ser:
            print "    "+dev
    else:
        print "    None"

    Menu.wait()

def probe_interfaces(p):
    Menu.clear()
    Discovery.probe()
    for cap,val in Discovery.capabilities.items():
        print "capability:", Discovery.description[cap]
        for ad in sorted(val, key=lambda a: a[0]):
            print "   ", ad[0], ad[2]
    Menu.wait()

def auto_configure_item(p):
    Menu.clear()
    auto_configure()
    Menu.wait()
    #TODO

config_menu = \
    Menu("Configuration",
         [
          [ 'Exit', Menu.stop, "help" ],
          [ 'Discover interfaces'        , discover_interfaces, "discover"    ],  #TODO replace with "select interfaces"
          [ 'Probe interfaces'           , probe_interfaces   , "probe"       ],
          [ 'Auto Configure'             , auto_configure_item, "autoconfigure"],
         #TODO save
         #TODO restore
         #[ '[xxxxx] toggle Interactive' , toggle_interactive , "interactive" ],
          [ '[xxxxx] toggle Clear Before Menu'         , toggle_clear       , "clear"       ],
          [ '[xxxxx] toggle Byte Offsets'              , toggle_byteoffsets , "byteoffsets" ],
          [ '[xxxxx] toggle Insert Shortcuts Into Menu', toggle_shortcuts   , "shortcuts"   ],
         #TODO breadcrumbs
          ])
def setup_config_menu():
    def display_current(name, value):
        data = config_menu.data
        for item in data:
            if item[2] == name:
                item[0] = "%7s%s" % ('[' + str(value) + ']', item[0][7:])
    display_current("interactive", Configuration.getInteractive())
    display_current("clear"      , Configuration.getClear      ())
    display_current("byteoffsets", Configuration.getByteoffsets())
    display_current("shortcuts"  , Configuration.getShortcuts  ())
def configure(p):
    setup_config_menu()
    config_menu.run(p)

bmc_menu = Menu("BMC", [['Exit', Menu.stop]])

# items in Platform menu
bpm_menu       = Menu("BPM"      , [['Exit', Menu.stop]])
ethernet_menu  = Menu("Ethernet" , [['Exit', Menu.stop]])
gpio_menu      = Menu("GPIO"     , [['Exit', Menu.stop]])
hdd_menu       = Menu("HDD"      , [['Exit', Menu.stop]])
memory_menu    = Menu("Memory"   , [['Exit', Menu.stop]])
pci_menu       = Menu("PCI"      , [['Exit', Menu.stop]])
processor_menu = Menu("Processor", [['Exit', Menu.stop]])
def reset(p): pass
smbus_menu     = Menu("SMBUS"    , [['Exit', Menu.stop]])
tpm_menu       = Menu("TPM"      , [['Exit', Menu.stop]])
usb_menu       = Menu("USB"      , [['Exit', Menu.stop]])

platform_menu = \
    Menu("Platform",
         [
          ['Exit'            , Menu.stop         , "help"      ],
          ['BPM Menu'        , bpm_menu      .run, "bpm"       ],
          ['Ethernet Menu'   , ethernet_menu .run, "ethernet"  ],
          ['GPIO Menu'       , gpio_menu     .run, "gpio"      ],
          ['HDD Menu'        , hdd_menu      .run, "hdd"       ],
          ['Memory Menu'     , memory_menu   .run, "memory"    ],
          ['PCI Menu'        , pci_menu      .run, "pci"       ],
          ['Processor Menu'  , processor_menu.run, "processor" ],
          ['Reset the System', reset             , "reset"     ],
          ['SMBUS Menu'      , smbus_menu    .run, "smbus"     ],
          ['TPM Menu'        , tpm_menu      .run, "tpm"       ],
          ['USB Menu'        , usb_menu      .run, "usb"       ],
          ])

# items in the SAS Drive menu

def drive_status(p):
    def drive_status_extras(typ, elnum, element, param):
        info = param
        if elnum == None:
            return ("%-16s" % "Product ID") + " " + ("%-8s" % "Serial Number")
        elif elnum < 0:
            return ""
        elif info[elnum]:
            pt = ScsiPT(info[elnum])
            inq = Cmd.inq(pt)
            del pt
            return ("%-16s" % inq.pid.val) + " " + ("%-8s" % inq.sn.val)
        else:
            return ""

    Menu.clear()
    # Read SAS addresses from SES page 0x0a.
    page01 = sp.parse(sp.readpage(0x01))
    page0a = sp.parse(sp.readpage(0x0a))
    #print "page0a =", "%X" % page0a["data"].descriptors.val[6].phydescriptors.val[0].sas_addr.val
    descriptors = page0a["data"].descriptors.val
    # Associate SAS address with element number.
    sas_addresses = {}
    for elnum in range(len(descriptors)):
        sas_address = descriptors[elnum].phydescriptors.val[0].sas_addr.val
        if sas_address != 0:
            sas_addresses["%x" % sas_address] = elnum
    info = [None] * len(descriptors)
    SASDEV = re.compile(r'sas.*-0x([0-9a-f]+)-lun-0 -> \.\./\.\./(sd[a-z]+)$')
    p = subprocess.Popen('ls -l /dev/disk/by-path'.split(), stdout=subprocess.PIPE).stdout
    for line in p:
        m = re.search(SASDEV, line)
        if m and m.group(1) in sas_addresses:
            info[sas_addresses[m.group(1)]] = '/dev/' + m.group(2)
    # Finally, print information on each drive.
    print_status(0x01, drive_status_extras, info)

    Menu.wait()

def drive_identify(p):
    def drive_identify_filter(typ, elnum, status, control, params):
        """
        SesPage.page02_fill calls this function for each element.
        If something is returned, it is added to the control page data with the SELECT bit set.
        Otherwise, it will add an empty element with the SELECT bit clear.

        Input:
          typ:     element type; we're expecting 0x03 for Cooling Element
          elnum:   element number, -1 for overall element
          status:  current values of this control element
          control: values to set in this control element
          params:  whatever was passed in to SesPage.page02
        Return:
          either a dictionary of values to set, if this is one we want to change,
          or None
        """
        if typ == 0x01:
            drive_id = params
            if elnum >= 0 and drive_id == "all" or drive_id == elnum:
                # Retain some current values.
                # Everything else is ignored by Wolf Creek.
                control["RQST FAULT"] = status.fault_reqstd.val
                control["DEVICE OFF"] = status.device_off.val
                # Set a new value.
                control["RQST IDENT"] = 1 - status.ident.val
                return control
        return None

    Menu.clear()
    if not sp: return

    try:
        drive_id = get_input("drive ID (0-n, all): ", p)
        try:
            drive_id = int(drive_id)
        except:
            pass
    except EOFError:
        return

    dat = sp.page_02_fill(drive_identify_filter, drive_id)
    result = sp.writepage(dat)

    Menu.wait()

def drive_pwroff(p):
    def drive_pwroff_filter(typ, elnum, status, control, params):
        """
        See comments on drive_identify_filter().
        """
        if typ == 0x01:
            drive_id = params
            if elnum >= 0 and drive_id == "all" or drive_id == elnum:
                # Retain some current values.
                # Everything else is ignored by Wolf Creek.
                control["RQST FAULT"] = status.fault_reqstd.val
                control["RQST IDENT"] = status.ident.val
                # Set a new value.
                control["DEVICE OFF"] = 1 - status.device_off.val
                return control
        return None

    Menu.clear()
    if not sp: return

    try:
        drive_id = get_input("drive ID (0-n, all): ", p)
        try:
            drive_id = int(drive_id)
        except:
            pass
    except EOFError:
        return

    dat = sp.page_02_fill(drive_pwroff_filter, drive_id)
    result = sp.writepage(dat)

    Menu.wait()

# items in the SAS Fan menu
def fan_status(p):
    Menu.clear()
    print_status(0x03)
    Menu.wait()

def fan_identify(p):
    def fan_identify_filter(typ, elnum, status, control, params):
        """
        See comments on drive_identify_filter().
        """
        if typ == 0x03:
            fan_id = params
            if elnum >= 0 and fan_id == "all" or fan_id == elnum:
                # Retain some current values.
                control["RQST FAIL" ] = status.fail.val
                # Set a new value.
                control["RQST IDENT"] = 1 - status.ident.val
                return control
        return None

    Menu.clear()
    #if not cli: return
    if not sp: return

    try:
        fan_id = get_input("fan ID (0-n, all): ", p)
        try:
            fan_id = int(fan_id)
        except:
            pass
    except EOFError:
        return

    #print cli.execute("fan identify " + fan_id)
    dat = sp.page_02_fill(fan_identify_filter, fan_id)
    result = sp.writepage(dat)

    Menu.wait()

def fan_speed(p):
    def fan_speed_filter(typ, elnum, status, control, params):
        """
        See comments on drive_identify_filter().
        """
        if typ == 0x03:
            speed, fan_id = params
            if elnum >= 0 and fan_id == "all" or fan_id == elnum:
                # Retain some current values.
                control["RQST IDENT"          ] = status.ident.val
                control["RQST FAIL"           ] = status.fail.val
                # Set a new value.
                control["REQUESTED SPEED CODE"] = speed
                return control
        return None

    Menu.clear()
    #if not cli: return
    if not sp: return

    try:
        speed  = get_input("speed code (1-7): ", p)
        fan_id = get_input("fan ID (0-n, all): ", p)
        try:
            speed  = int(speed )
        except:
            print "Speed code must be an integer."
            Menu.wait()
            return
        try:
            fan_id = int(fan_id)
        except:
            pass
        if fan_id == "":
            fan_id = "all"
    except EOFError:
        return

    dat = sp.page_02_fill(fan_speed_filter, (speed, fan_id))
    result = sp.writepage(dat)

    #if fan_id == "all" or fan_id == "":
    #    fan_selection = 0xffff
    #else:
    #    fan_selection = 1 << int(fan_id)

    #print cli.execute("fan speed " + speed + ' ' + str(fan_selection))
    Menu.wait()

# items in the SAS Power Supply menu
def powersupply_status(p):
    Menu.clear()
    print_status(0x02)
    Menu.wait()

def powersupply_longstatus(p):
    def powersupply_status_extras(typ, elnum, element, param):
        typelist = param
        if elnum == None:
            return ""
        elif elnum < 0:
            return ""
        else:
            # Add 1 to allow for the overall element.
            return "\n" + indentedtext("             ", typelist[elnum+1].text.val, "")

    Menu.clear()
    # Retrieve the element descriptors so we can print them.
    page01 = sp.parse(sp.readpage(0x01))
    page07 = sp.parse(sp.readpage(0x07))
    for typ in page07["data"].enclosures.val[0]:
        if typ["type"] == 0x02:
            break
    print_status(0x02, powersupply_status_extras, typ["elements"])
    Menu.wait()

def powersupply_identify(p):
    def powersupply_identify_filter(typ, elnum, status, control, params):
        """
        See comments on drive_identify_filter().
        """
        if typ == 0x02:
            psu_id = params
            if elnum >= 0 and psu_id == "all" or psu_id == elnum:
                # Retain some current values.
                control["RQST FAIL" ] = status.fail.val
                # Set a new value.
                control["RQST IDENT"] = 1 - status.ident.val
                return control
        return None

    Menu.clear()
    #if not cli: return
    if not sp: return

    try:
        psu_id = get_input("PSU ID (0-n, all): ", p)
        try:
            psu_id = int(psu_id)
        except:
            pass
    except EOFError:
        return

    #print cli.execute("fan identify " + fan_id)
    dat = sp.page_02_fill(powersupply_identify_filter, psu_id)
    result = sp.writepage(dat)

    Menu.wait()


# items in SAS menu

cpld_menu        = Menu("CPLD"          , [['Exit', Menu.stop]])

drive_menu       = \
    Menu("Drive"         ,
         [
          ['Exit'            , Menu.stop     , "help"    ],
          ['Status'          , drive_status  , "status"  ],
          ['Toggle Identify' , drive_identify, "identify"],
          ['Toggle Power'    , drive_pwroff  , "pwroff"  ],
          ])

def enclosure_status     (p):
    Menu.clear()
#     if not cli: return
#     print cli.execute("info")
    if not sp_short: return
    page01 = sp_short.parse(sp_short.readpage(0x01))
    for enclist in page01["data"].enclosures.val:
        pbo(enclist.subid   ); print "Enclosure #" + str(enclist.subid.val)
        pbo(enclist.logid   ); print "    %-31s:" % enclist.logid   .desc, "%X" % enclist.logid   .val
        pbo(enclist.vendor  ); print "    %-31s:" % enclist.vendor  .desc, enclist.vendor  .val
        pbo(enclist.product ); print "    %-31s:" % enclist.product .desc, enclist.product .val
        pbo(enclist.revision); print "    %-31s:" % enclist.revision.desc, enclist.revision.val
    Menu.wait()

fan_menu         = \
    Menu("Fan"           ,
         [
          ['Exit'           , Menu.stop   , "help"    ],
          ['Status'         , fan_status  , "status"  ],
          ['Toggle Identify', fan_identify, "identify"],
          ['Speed'          , fan_speed   , "speed"   ],
          ])

powersupply_menu = \
    Menu("Power Supply"  ,
         [
          ['Exit'           , Menu.stop             , "help"      ],
          ['Status'         , powersupply_status    , "status"    ],
          ['Long Status'    , powersupply_longstatus, "longstatus"],
          ['Toggle Identify', powersupply_identify  , "identify"  ],
          ])

def flash_expander_image (p): pass
lcd_menu         = Menu("LCD"           , [['Exit', Menu.stop]])
led_menu         = Menu("LED"           , [['Exit', Menu.stop]])
log_menu         = Menu("Log"           , [['Exit', Menu.stop]])
phy_menu         = Menu("PHY"           , [['Exit', Menu.stop]])
def rebootreset_expander (p): pass
sensor_menu      = Menu("Sensor"        , [['Exit', Menu.stop]])
ses_menu = \
    Menu("SES Page Dump",
         [
          ['Exit', Menu.stop, "help"],
          ['All Pages'                            , sespageall, "all"],
          ['Page 0x00: Supported Diagnostic Pages', sespage00, "0x00"],
          ['Page 0x01: Configuration'             , sespage01, "0x01"],
          ['Page 0x02: Enclosure Status'          , sespage02, "0x02"],
         #['Page 0x04: String In'                 , sespage04, "0x04"],
          ['Page 0x05: Threshold In'              , sespage05, "0x05"],
          ['Page 0x07: Element Descriptor'        , sespage07, "0x07"],
          ['Page 0x0a: Additional Element'        , sespage0a, "0x0a"],
          ['Page 0x0e: Download Microcode Status' , sespage0e, "0x0e"],
          ['Page 0x80: Event Log'                 , sespage80, "0x80"], # SK and PG
         #['Page 0x82: SXP Firmware Status'       , sespage82, "0x82"], # PG only
         #['Page 0x91: SXP Boot Configuration Status', sespage91, "0x91"], # BM only
         #['Page 0x92: Low Power Condition Status', sespage92, "0x92"], # BM only
          ['Page 0xe0: Report PHY Status'         , sespagee0, "0xe0"], # ST only
          ['Page 0xe1: Report PHY Status'         , sespagee1, "0xe1"], # ST only
          ['Page 0xe2: Report PHY Status'         , sespagee2, "0xe2"], # ST only
          ['Page 0xe3: Report PHY Status'         , sespagee3, "0xe3"], # ST only
          ['Page 0xe4: Report PHY Status'         , sespagee4, "0xe4"], # ST only
          ['Page 0xe5: Report PHY Status'         , sespagee5, "0xe5"], # ST only
          ['Page 0xe8: CLI Command In'            , sespagee8, "0xe8"], # ST only
         #['Page 0xe9: Product Type Flag Status'  , sespagee9, "0xe9"],
          ])
        # WC: Wolf Creek
        # BM: Blue Moon
        # ST: Skytree addendum to Blue Moon
        # PG: Pinot Grigio
twi_menu         = Menu("TWI"           , [['Exit', Menu.stop]])
vpd_menu         = Menu("VPD"           , [['Exit', Menu.stop]])

sas_menu = \
    Menu("SAS",
         [
          ['Exit'                 , Menu.stop           , "help"               ],
          [        '(X)CPLD Menu'    ,        cpld_menu.run, "cpld"               ],
          [       'Drive Menu'    ,       drive_menu.run, "drive"              ],
          ['Enclosure Status'     , enclosure_status    , "enclosure"          ],
          [         'FAN Menu'    ,         fan_menu.run, "fan"                ],
          ['(X)Flash Expander Image' , flash_expander_image, "flashexpanderimage" ],
          [         '(X)LCD Menu'    ,         lcd_menu.run, "lcd"                ],
          [         '(X)LED Menu'    ,         led_menu.run, "led"                ],
          [         '(X)LOG Menu'    ,         log_menu.run, "log"                ],
          [         '(X)PHY Menu'    ,         phy_menu.run, "phy"                ],
          ['Power Supply Menu'    , powersupply_menu.run, "powersupply"        ],
          ['(X)Reboot/Reset Expander', rebootreset_expander, "reboot"             ],
          [      '(X)Sensor Menu'    ,      sensor_menu.run, "sensor"             ],
          ['SES Page Dump'        , sespages            , "ses"                ],
          [         '(X)TWI Menu'    ,         twi_menu.run, "twi"                ],
          [         '(X)VPD Menu'    ,         vpd_menu.run, "vpd"                ],
          ])

utility_menu = \
    Menu("Debug Utility",
         [
          ['Exit'              , Menu.stop        , "help"     ],
          ['Configuration Menu', configure        , "configure"],
          ['(X)BMC Menu'          , bmc_menu     .run, "bmc"      ],
          ['(X)Platform Menu'     , platform_menu.run, "platform" ],
          ['SAS Menu'          , sas_menu     .run, "sas"      ],
          ])

# Parse command-line options.
parser = argparse.ArgumentParser(description="Wolf Creek Debug Utility -- Display information about a Jabil system.")
parser.add_argument("--probe"      , action="store_true", help="Probe the system to find appropriate and best device files.")
parser.add_argument("--cli"        , nargs=1, type=str,   help="device file to use for CLI access; include comma (',') and port number if sg device")
parser.add_argument("--sespage"    , nargs=1, type=str,   help="device file to use for SES Page access")
parser.add_argument("--verbose"    , action="store_true", help="Print some things not normally printed.")
parser.add_argument("--notclear"   , action="store_true", help="Don't clear the screen before printing menus and data.")
parser.add_argument("--byteoffsets", action="store_true", help="Print data offsets from beginnings of SES pages.")
parser.add_argument("--shortcuts"  , action="store_true", help="Print command-line shortcuts on menus.")
params, commands = parser.parse_known_args()
params = vars(params)

verbose = params["verbose"]

# If we passed keyword parameters, don't clear the screen or wait.
Configuration.setInteractive(not commands)

# Set more configuration elements based on command-line options.
if params["notclear"   ]: Configuration.setClear      (False)
if params["byteoffsets"]: Configuration.setByteoffsets(True)
if params["shortcuts"  ]: Configuration.setShortcuts  (True)

# Configure accessors.
if params["probe"]:
    auto_configure()
# "cli" and "sespage" can override the results of "probe".
if params["cli"]:
    cli = CliCmd_create(params["cli"][0])
if params["sespage"]:
    sp  = SesPage_create(params["sespage"][0])
    sp_short = sp

# Run the main menu.
utility_menu.run(commands)

Discovery.close_all()
#if sp      : sp      .close()
#if sp_short: sp_short.close()
#if cli     : cli     .close()

