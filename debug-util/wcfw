#!/usr/bin/env python

"""
Wolf Creek FirmWare utility
"""
version = "0.2.0"

import sys
import os
import argparse

from firmwarewc   import FirmwareBmc, FirmwareBios
from firmwarewc   import FirmwareU199, FirmwareU187, FirmwareU112
from firmwarewc   import FirmwareSas, FirmwareBoot, FirmwareWcbb, FirmwareWcmi, FirmwareWcssm
from firmwarefile import FirmwareTypes, FirmwareFile

type_bmc   = "bmc"
type_bios  = "bios"
type_u112  = "u112"
type_u187  = "u187"
type_u199  = "u199"
type_u1000 = "u1000"
type_u1001 = "u1001"
type_u1002 = "u1002"
type_u1003 = "u1003"
type_u1004 = "u1004"
type_u1005 = "u1005"
type_u1006 = "u1006"
type_sas   = "sas"
type_boot  = "boot"
type_bb    = "bb"
type_mi    = "mi"
type_ssm   = "ssm"
type_list  = [
    type_bmc,
    type_bios,
#     type_u112,
#     type_u187,
#     type_u199,
#     type_u1000,
#     type_u1001,
#     type_u1002,
#     type_u1003,
#     type_u1004,
#     type_u1005,
#     type_u1006,
    type_sas,
    type_boot,
    type_bb,
    type_mi,
    type_ssm,
    ]
type_map = {
    type_bmc  : FirmwareTypes.WCBMC ,
    type_bios : FirmwareTypes.WCBIOS,
#     type_u112 : FirmwareTypes.U112  ,
#     type_u187 : FirmwareTypes.U187  ,
#     type_u199 : FirmwareTypes.U199  ,
#     type_u1000: FirmwareTypes.U1000 ,
#     type_u1001: FirmwareTypes.U1001 ,
#     type_u1002: FirmwareTypes.U1002 ,
#     type_u1003: FirmwareTypes.U1003 ,
#     type_u1004: FirmwareTypes.U1004 ,
#     type_u1005: FirmwareTypes.U1005 ,
#     type_u1006: FirmwareTypes.U1006 ,
#    type_sas  : FirmwareTypes.WCISTR,
    type_sas  : FirmwareTypes.WCISTR,
    type_boot : FirmwareTypes.WCBOOT,
    type_bb   : FirmwareTypes.WCBB  ,
    type_mi   : FirmwareTypes.WCMI  ,
    type_ssm  : FirmwareTypes.WCSSM ,
    }
# Types that are satisified by firmware in a SAS_ALL_IN_ONE bundle
SASexp_all_types = set([
    type_sas ,
    type_bb  ,
    type_mi  ,
    type_ssm ,
    ])
# Types that need a serial port.
SASexp_types = SASexp_all_types | set([
    type_boot,
    ])

def print_expander_version(label, vers):
    if FirmwareTypes.APP    in vers: print label, "app :", vers[FirmwareTypes.APP   ]
    if FirmwareTypes.BOOT   in vers: print label, "boot:", vers[FirmwareTypes.BOOT  ]
    if FirmwareTypes.WCBB   in vers: print label, "bb  :", vers[FirmwareTypes.WCBB  ]
    if FirmwareTypes.WCMI   in vers: print label, "mi  :", vers[FirmwareTypes.WCMI  ]
    if FirmwareTypes.WCSSM  in vers: print label, "ssm :", vers[FirmwareTypes.WCSSM ]

##### main
epilog = """
If --type is not given, it defaults to "all".
The parameter to the --type switch may be a comma-separated list.
Each element in the list may optionally have an equals sign ("=") and
  a version number appended, e.g. --type bmc=0009,bios=0205.
""" + "Program version: "+version
#"""The version number may be the string "latest" to allow the program to pick the version that sorts the highest."""
parser = argparse.ArgumentParser(description="Jabil Firmware Update, Wolf Creek", epilog=epilog, formatter_class=argparse.RawDescriptionHelpFormatter, )
parser.add_argument("--type"    , nargs=1, type=str,   help='types of things to update, or "help" or "all"')
parser.add_argument("--firmware", nargs=1, type=str,   help="firmware file, directory, or archive (e.g. 7z or zip)")
parser.add_argument("--instance", nargs=1, type=int,   help="instance 0 or 1 for SAS or CPLD")
parser.add_argument("--serial"  , nargs=1, type=str,   help="serial port device file for SAS or CPLD")
#parser.add_argument("--force"   , action="store_true", help="update even if version matches")
parser.add_argument("--info"    , action="store_true", help="only print version information of files and hardware")
parser.add_argument("--dryrun"  , action="store_true", help="do not attempt any operations on the hardware")
parser.add_argument("--powercpld", action="store_true", help="After updating the BMC, run this command to finish updating the power CPLD. NOTE: The canister will reset in two minutes. Linux will be shutdown immediately.")
# info=False, dryrun=False: fw versions, hw versions, program, hw versions
# info=False, dryrun=True : config OK or error
# info=True , dryrun=False: fw versions, hw versions, what won't be programmed unless forced
# info=True , dryrun=True : fw versions
if len(sys.argv) == 1:
    # No switches: print usage and exit.
    parser.print_usage()
    sys.exit(0)
params = parser.parse_args()
progname = sys.argv[0].split('/')[-1]

# Are we simply wanting to update the Power CPLD after updating BMC?
if params.powercpld:
    if params.type or params.firmware or params.instance or params.serial:
        # It is most likely a mistake to include --powercpld with other parameters, except --dryrun.
        print "--powercpld is incompatible with most other switches. Run again by itself."
        sys.exit(4)
    print "--powercpld will reset the canister in 2 minutes and shutdown Linux immediately."
    if not params.dryrun:
        try:
            raw_input("Are you sure you want to do this? Hit <ctrl>-C to abort or <enter> to continue.")
            FirmwareBmc().update_cpld()
        except:
            pass
    sys.exit(0)
    
# params.firmware is handled later.

if not params.instance:
    # Default instances. It works better overall to update instance 1 before instance 0.
    params.instance = [1,0]

# Parse parameter to --type switch.
typ = ','.join(params.type) if params.type else "all"  # Make comma-separated list; default to all.
type_do = typ.split(',')
param_versions = {}
for ix in range(len(type_do)):
    # Extract any given version numbers.
    typ = type_do[ix]
    tv = typ.split('=')
    if len(tv) > 1:
        # Version was specified.
        t,v = tv    # type and version
        param_versions[t] = v
        type_do[ix] = t  # Replace type=version in list with just type. 

#TODO: allow abbreviations
# Check parameter to --type switch.
for typ in type_do:
    if typ == "help" or typ not in ["all"] + type_list:
        if typ != "help":
            print 'Type "'+typ+'" is invalid.'
        print 'Please choose a parameter to the "--type" switch from the following:'
        for t in ["help", "all"] + type_list:
            print "  "+t
        print 'See "'+progname+' --help" for details of the parameter to --type.'
        sys.exit(2)
    if typ == "all":
        type_do = type_list
        break

# type_all = [
#     FirmwareTypes.WCBMC ,
#     FirmwareTypes.WCBIOS,
# #     FirmwareTypes.U112 ,
# #     FirmwareTypes.U187 ,
# #     FirmwareTypes.U199 ,
#     FirmwareTypes.WCISTR,
#     FirmwareTypes.WCBOOT,
#     FirmwareTypes.WCBB  ,
#     FirmwareTypes.WCMI  ,
#     FirmwareTypes.WCSSM ,
#     ]

if os.geteuid() != 0 and not params.dryrun:
    print "This program must be run as superuser,"
    print "i.e. log in as root or prefix the command with sudo."
    sys.exit(1)

error = False

# Unpack firmware.
fw_file = FirmwareFile(params.firmware[0]) if params.firmware else None
# Find all available versions of the requested types. Check for missing or multiples.
file_versions = {}
if fw_file:
    for tl in fw_file.get_filename().values():
        for typm in tl:
            if typm not in file_versions:
                # Create an entry for this typm.
                file_versions[typm] = set()
            file_versions[typm] |= set(tl[typm])
    # Check all specified types.
    need_multiversion_help = False
    for typ in type_do:
        typm = type_map[typ]
        if typ in param_versions:
            # Version was specified on command line.
            if typm in file_versions and param_versions[typ] in file_versions[typm]:
                file_versions[typm] = set([param_versions[typ]])
            else:
                print "Version", param_versions[typ], "requested for", typ, "but it wasn't found."
                error = True
        else:
            # No version specified: must have exactly one to choose from.
            if typm not in file_versions:
                print "There is no version of firmware for", typ
            else:
                if len(file_versions[typm]) > 1:
                    print "There is more than one version of", typ, "firmware:"
                    for v in sorted(file_versions[typm]):
                        print "    "+v
                    error = True
                    need_multiversion_help = True
    if need_multiversion_help:
        print 'Run "'+progname+' --help" to determine how to specify a version.'
    del need_multiversion_help

# Make sure we know a serial port, if needed.
if not params.dryrun and not params.serial:
    for typ in type_do:
        if typ in SASexp_types:
            print 'error: argument --serial is required when --type='+typ
            error = True
            
if params.info:
    print "Requested and available versions:"
    for typ in type_do:
        typm = type_map[typ]
        pre = "%-5s: " % typ
        if typm not in file_versions:
            print pre + "----"
        else:
            for v in sorted(file_versions[typm]):
                print pre + v
                pre = "%7s" % ""

if error:
    print "There was an error; aborting."
    sys.exit(3)

summary = {}

for typ in type_do:

    typm = type_map[typ]

    summary[typ] = {}
    version = list(file_versions[typm])[0] if typm in file_versions else '----'
    summary[typ]["file_version"] = version

    loop_over_instance = False
    instances = [0]

    if not params.dryrun:
        class_map = {
            type_bmc : FirmwareBmc  ,
            type_bios: FirmwareBios ,
            type_u112: FirmwareU112 ,
            type_u187: FirmwareU187 ,
            type_u199: FirmwareU199 ,
            type_sas : FirmwareSas  ,
            type_boot: FirmwareBoot ,
            type_bb  : FirmwareWcbb ,
            type_mi  : FirmwareWcmi ,
            type_ssm : FirmwareWcssm,
            }
        fw = class_map[typ]()
        if typ in SASexp_types:
            fw.set_serial(params.serial[0])
            loop_over_instance = True
            instances = params.instance
    
        for instance in instances:
            if loop_over_instance:
                fw.set_expnum(instance)
            summary[typ]["current_version"] = fw.version()  #TODO: instances
            print "Current version:", summary[typ]["current_version"]
            if not params.info:
                # Get file name.
                if fw_file:
                    for tl in fw_file.get_filename().values():
                        if typm in tl:
                            filename = tl[typm][version]
                            break
                    else:
                        filename = None
                else:
                    filename = None
                fw.update(filename)
                summary[typ]["new_version"] = fw.version()
                print "New version:    ", summary[typ]["new_version"]

print
print "Summary"
print "======="
typ = type_do[0]
print "%-5s" % "Type",
if "file_version" in summary[typ]:
    print "%-4s" % "File",
if "current_version" in summary[typ]:
    print "%-4s" % "Curr",
if "new_version" in summary[typ]:
    print "%-4s" % "New",
print
print "%-5s" % "----",
if "file_version" in summary[typ]:
    print "%-4s" % "----",
if "current_version" in summary[typ]:
    print "%-4s" % "----",
if "new_version" in summary[typ]:
    print "%-4s" % "----",
print

for typ in type_do:
    print "%-5s" % typ,
    if "file_version" in summary[typ]:
        print "%-4s" % summary[typ]["file_version"],
    if "current_version" in summary[typ]:
        print "%-4s" % summary[typ]["current_version"],
    if "new_version" in summary[typ]:
        print "%-4s" % summary[typ]["new_version"],
    print
