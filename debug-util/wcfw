#!/usr/bin/env python

"""
Wolf Creek FirmWare utility
"""
version = "0.2.2"

import sys
import os
import argparse

from firmwarewc   import FirmwareBmc, FirmwareBios
from firmwarewc   import FirmwareU199, FirmwareU187, FirmwareU112
from firmwarewc   import FirmwareSas0, FirmwareSas1, FirmwareBoot0, FirmwareBoot1, FirmwareWcbb, FirmwareWcmi, FirmwareWcssm
from firmwarefile import FirmwareTypes, FirmwareUtils, FirmwareFile

type_bmc   = "bmc"
type_bios  = "bios"
type_u112  = "u112"
type_u187  = "u187"
type_u199  = "u199"
type_u1000 = "u1000"
type_u1001 = "u1001"
type_u1002 = "u1002"
type_u1003 = "u1003"
type_u1004 = "u1004"
type_u1005 = "u1005"
type_u1006 = "u1006"
type_sas0  = "sas0"
type_sas1  = "sas1"
type_boot0 = "boot0"
type_boot1 = "boot1"
type_bb    = "bb"
type_mi    = "mi"
type_ssm   = "ssm"
type_list  = [
    type_bmc,
    type_bios,
#     type_u112,
#     type_u187,
#     type_u199,
#     type_u1000,
#     type_u1001,
#     type_u1002,
#     type_u1003,
#     type_u1004,
#     type_u1005,
#     type_u1006,
    type_sas1,
    type_sas0,
    type_boot1,
    type_boot0,
    type_bb,
    type_mi,
    type_ssm,
    ]
type_map = {
    type_bmc  : FirmwareTypes.WCBMC ,
    type_bios : FirmwareTypes.WCBIOS,
#     type_u112 : FirmwareTypes.U112  ,
#     type_u187 : FirmwareTypes.U187  ,
#     type_u199 : FirmwareTypes.U199  ,
#     type_u1000: FirmwareTypes.U1000 ,
#     type_u1001: FirmwareTypes.U1001 ,
#     type_u1002: FirmwareTypes.U1002 ,
#     type_u1003: FirmwareTypes.U1003 ,
#     type_u1004: FirmwareTypes.U1004 ,
#     type_u1005: FirmwareTypes.U1005 ,
#     type_u1006: FirmwareTypes.U1006 ,
#    type_sas  : FirmwareTypes.WCISTR,
    type_sas0 : FirmwareTypes.WCISTR,
    type_sas1 : FirmwareTypes.WCISTR,
    type_boot0: FirmwareTypes.WCBOOT,
    type_boot1: FirmwareTypes.WCBOOT,
    type_bb   : FirmwareTypes.WCBB  ,
    type_mi   : FirmwareTypes.WCMI  ,
    type_ssm  : FirmwareTypes.WCSSM ,
    }
# Types that are satisified by firmware in a SAS_ALL_IN_ONE bundle
SASexp_all_types = set([
    type_sas0,
    type_sas1,
    type_bb  ,
    type_mi  ,
    type_ssm ,
    ])
# Types that need a serial port.
SASexp_types = SASexp_all_types | set([
    type_boot0,
    type_boot1,
    ])

def print_expander_version(label, vers):
    if FirmwareTypes.APP    in vers: print label, "app :", vers[FirmwareTypes.APP   ]
    if FirmwareTypes.BOOT   in vers: print label, "boot:", vers[FirmwareTypes.BOOT  ]
    if FirmwareTypes.WCBB   in vers: print label, "bb  :", vers[FirmwareTypes.WCBB  ]
    if FirmwareTypes.WCMI   in vers: print label, "mi  :", vers[FirmwareTypes.WCMI  ]
    if FirmwareTypes.WCSSM  in vers: print label, "ssm :", vers[FirmwareTypes.WCSSM ]

##### main
epilog = """
If --type is not given, it defaults to "all".
The parameter to the --type switch may be a comma-separated list.
Each element in the list may optionally have an equals sign ("=") and
  a version number appended, e.g. --type bmc=0009,bios=0205.
""" + "Program version: "+version
#"""The version number may be the string "latest" to allow the program to pick the version that sorts the highest."""
parser = argparse.ArgumentParser(description="Jabil Firmware Update, Wolf Creek", epilog=epilog, formatter_class=argparse.RawDescriptionHelpFormatter, )
parser.add_argument("--type"    , nargs=1, type=str,   help='types of things to update, or "help" or "all"')
parser.add_argument("--firmware", nargs=1, type=str,   help="firmware file, directory, or archive (e.g. 7z or zip)")
parser.add_argument("--serial"  , nargs=1, type=str,   help="serial port device file for SAS or CPLD")
#parser.add_argument("--force"   , action="store_true", help="update even if version matches")
parser.add_argument("--info"    , action="store_true", help="only print version information of files and hardware")
parser.add_argument("--dryrun"  , action="store_true", help="do not attempt any operations on the hardware")
parser.add_argument("--verbosity", nargs=1, type=int,  help="How noisy should the output be? (0, 1, 2; default 1)", default=[1])
parser.add_argument("--activatecpld", action="store_true", help="After updating the BMC, run this command to finish updating the power CPLD. NOTE: The canister will reset in two minutes. Linux will be shutdown immediately.")
parser.add_argument("--activatepsoc", action="store_true", help="After updating the BMC, run this command to finish updating the PSoC.")
# info=False, dryrun=False: fw versions, hw versions, program, hw versions
# info=False, dryrun=True : config OK or error
# info=True , dryrun=False: fw versions, hw versions, what won't be programmed unless forced
# info=True , dryrun=True : fw versions
if len(sys.argv) == 1:
    # No switches: print usage and exit.
    parser.print_usage()
    sys.exit(0)
params = parser.parse_args()
progname = sys.argv[0].split('/')[-1]

# Are we simply wanting to activate the PSoC firmware after updating BMC?
if params.activatepsoc:
    if params.type or params.firmware or params.serial:
        # It is most likely a mistake to include --activatepsoc with other parameters, except --dryrun.
        print "--activatepsoc is incompatible with most other switches. Run again by itself."
        sys.exit(4)
    if not params.dryrun:
        try:
            FirmwareBmc().activate_psoc()
        except:
            pass
    
# Are we simply wanting to activate the Power CPLD firmware after updating BMC?
if params.activatecpld:
    if params.type or params.firmware or params.serial:
        # It is most likely a mistake to include --activatecpld with other parameters, except --dryrun.
        print "--activatecpld is incompatible with most other switches. Run again by itself."
        sys.exit(4)
    print "--activatecpld will reset the canister in 2 minutes and shutdown Linux immediately."
    if not params.dryrun:
        try:
            raw_input("Are you sure you want to do this? Hit <ctrl>-C to abort or <enter> to continue.")
            FirmwareBmc().activate_cpld()
        except:
            pass
    sys.exit(0)
    
# params.firmware is handled later.

# Parse parameter to --type switch.
typ = ','.join(params.type) if params.type else "all"  # Make comma-separated list; default to all.
type_do = typ.split(',')
param_versions = {}
for ix in range(len(type_do)):
    # Extract any given version numbers.
    typ = type_do[ix]
    tv = typ.split('=')
    if len(tv) > 1:
        # Version was specified.
        t,v = tv    # type and version
        param_versions[t] = FirmwareUtils.normalize_version(v)
        type_do[ix] = t  # Replace type=version in list with just type. 

#TODO: allow abbreviations
# Check parameter to --type switch.
for typ in type_do:
    if typ == "help" or typ not in ["all"] + type_list:
        if typ != "help":
            print 'Type "'+typ+'" is invalid.'
        print 'Please choose a parameter to the "--type" switch from the following:'
        for t in ["help", "all"] + type_list:
            print "  "+t
        print 'See "'+progname+' --help" for details of the parameter to --type.'
        sys.exit(2)
    if typ == "all":
        type_do = type_list
        break

# type_all = [
#     FirmwareTypes.WCBMC ,
#     FirmwareTypes.WCBIOS,
# #     FirmwareTypes.U112 ,
# #     FirmwareTypes.U187 ,
# #     FirmwareTypes.U199 ,
#     FirmwareTypes.WCISTR,
#     FirmwareTypes.WCBOOT,
#     FirmwareTypes.WCBB  ,
#     FirmwareTypes.WCMI  ,
#     FirmwareTypes.WCSSM ,
#     ]

if os.geteuid() != 0 and not params.dryrun:
    print "This program must be run as superuser,"
    print "i.e. log in as root or prefix the command with sudo."
    sys.exit(1)

error = False

# Unpack firmware.
fw_file = FirmwareFile(params.firmware[0]) if params.firmware else None
# Find all available versions of the requested types. Check for missing or multiples.
file_versions = {}
if fw_file:
    for tl in fw_file.get_filename().values():
        for typm in tl:
            if typm not in file_versions:
                # Create an entry for this typm.
                file_versions[typm] = set()
            file_versions[typm] |= set(tl[typm])
    # Check all specified types.
    need_multiversion_help = False
    for typ in type_do:
        typm = type_map[typ]
        if typ in param_versions:
            # Version was specified on command line.
            if typm in file_versions and param_versions[typ] in file_versions[typm]:
                file_versions[typm] = set([param_versions[typ]])
            else:
                print "Version", param_versions[typ], "requested for", typ, "but it wasn't found."
                error = True
        else:
            # No version specified: must have exactly one to choose from.
            if typm not in file_versions:
                print "There is no version of firmware for", typ
            else:
                if len(file_versions[typm]) > 1 and not params.info:
                    print "There is more than one version of", typ, "firmware:"
                    for v in sorted(file_versions[typm]):
                        print "    "+v
                    error = True
                    need_multiversion_help = True
    if need_multiversion_help:
        print 'Run "'+progname+' --help" to determine how to specify a version.'
    del need_multiversion_help

# Make sure we know a serial port, if needed.
if not params.dryrun and not params.serial:
    for typ in type_do:
        if typ in SASexp_types:
            print 'error: argument --serial is required when --type='+typ
            error = True
            
# if params.info:
#     print "Requested and available versions:"
#     for typ in type_do:
#         typm = type_map[typ]
#         pre = "%-5s: " % typ
#         if typm not in file_versions:
#             print pre + "----"
#         else:
#             for v in sorted(file_versions[typm]):
#                 print pre + v
#                 pre = "%7s" % ""

if error:
    print "There was an error; aborting."
    sys.exit(3)

# Perform the operation.

summary = {}

for typ in type_do:

    typm = type_map[typ]

    summary[typ] = {}
    versions = sorted(list(file_versions[typm])) if typm in file_versions else ['----']
    summary[typ]["file_version"] = versions

    if not params.dryrun:  # We are allowed to touch the hardware.
        class_map = {
            type_bmc  : FirmwareBmc  ,
            type_bios : FirmwareBios ,
            type_u112 : FirmwareU112 ,
            type_u187 : FirmwareU187 ,
            type_u199 : FirmwareU199 ,
            type_sas0 : FirmwareSas0 ,
            type_sas1 : FirmwareSas1 ,
            type_boot0: FirmwareBoot0,
            type_boot1: FirmwareBoot1,
            type_bb   : FirmwareWcbb ,
            type_mi   : FirmwareWcmi ,
            type_ssm  : FirmwareWcssm,
            }
        fw = class_map[typ]()
        if typ in SASexp_types:
            fw.set_serial(params.serial[0])
        fw.set_verbosity(params.verbosity[0])
    
        summary[typ]["current_version"] = fw.version()
        if params.verbosity[0] >= 1:
            print "Current version:", summary[typ]["current_version"]
        if not params.info:  # Not just info; actually program firmware.
            # Get file name.
            if fw_file:
                for tl in fw_file.get_filename().values():
                    if typm in tl:
                        filename = tl[typm][version]
                        break
                else:
                    filename = None
            else:
                filename = None
            fw.update(filename)  # Program firmware into this part.
            summary[typ]["new_version"] = fw.version()
            if params.verbosity[0] >= 1:
                print "New version:    ", summary[typ]["new_version"]

if params.verbosity[0] >= 0:
    print
    print "Summary"
    print "======="
    typ = type_do[0]
    print "%-5s" % "Type",
    if "file_version" in summary[typ]:
        print "%-4s" % "File",
    if "current_version" in summary[typ]:
        print "%-4s" % "Curr",
    if "new_version" in summary[typ]:
        print "%-4s" % "New",
    print
    print "%-5s" % "----",
    if "file_version" in summary[typ]:
        print "%-4s" % "----",
    if "current_version" in summary[typ]:
        print "%-4s" % "----",
    if "new_version" in summary[typ]:
        print "%-4s" % "----",
    print
    
    for typ in type_do:
        print "%-5s" % typ,
        if "file_version" in summary[typ]:
            print "%-4s" % summary[typ]["file_version"][0],
        if "current_version" in summary[typ]:
            print "%-4s" % summary[typ]["current_version"],
        if "new_version" in summary[typ]:
            print "%-4s" % summary[typ]["new_version"],
        print
        if "file_version" in summary[typ]:
            for v in summary[typ]["file_version"][1:]:
                print "%-5s" % "",
                print "%-4s" % v,
                print
